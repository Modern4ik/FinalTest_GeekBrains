# **Программа для формирования массива строк, длина которых меньше или равна 3 символам из исходного массива, полученного от пользователя. Написано на C#**

![Приветственный GIF](https://media.giphy.com/media/8Iv5lqKwKsZ2g/giphy.gif)

*Доброго времени суток, уважаемые гости моего репозитория, а особенно преподаватели GeekBrains! Хочу представить вам моё решение итоговой контрольной работы по основному блоку программы обучения "Разработчик".*

*В данном репозитории вы найдете сам код программы в папке TestSolution, в файле Program.cs.*

*Данная программа призвана генерировать новый массив строк, длина элементов которого меньше или равноа 3 символам,  из исходного, который мы получили от пользователя.*
______
*Давайте определим список тем, по которым мы пройдемся, дабы лучше понять мой код:*

### **Главы:**

+ [Общее описание алгоритма программы.](#общее-описание-алгоритма-программы)
    + [Общая блок-схема алгоритма решения задачи.](#общая-блок-схема-алгоритма-решения-задачи)
    + [Текстовое описание общей работы алгоритма.](#текстовое-описание-общей-работы-алгоритма-программы)
___
+ [Описание алгоритма блока ввода данных.](#описание-алгоритма-блока-ввода-данных)
    + [Блок-Схема аргоритма метода GetValueFromUser.](#блок-схема-аргоритма-метода-getvaluefromuser)
    + [Текстовое описание алгоритма работы метода GetValueFromUser.](#текстовое-описание-алгоритма-работы-метода-getvaluefromuser)
    + [Описание метода GetValueFromUser в коде программы.](#описание-метода-getvaluefromuser-в-коде-программы)
    + [Блок-Схема алгоритма метода GetAndFillArrayByUser.](#блок-схема-алгоритма-метода-getandfillarraybyuser)
    + [Описание метода GetAndFillArrayByUser в коде программы.](#описание-метода-getandfillarraybyuser-в-коде-программы)
    + [Текстовое описание алгоритма работы метода GetAndFillArrayByUser.](#текстовое-описание-алгоритма-работы-метода-getandfillarraybyuser)
___
+ [Описание алгоритма блока операций с полученными данными.](#описание-алгоритма-блока-операций-с-полученными-данными)
    + [Текстовое описание работы алгоритма метода по выводу исходного массива, PrintArray.](#текстовое-описание-работы-алгоритма-метода-по-выводу-исходного-массива-printarray)
    + [Описание метода PrintArray в коде программы.](#описание-метода-printarray-в-коде-программы)
    + [Блок-Схема алгоритма метода GetSortedArray.](#блок-схема-алгоритма-метода-getsortedarray)
    + [Описание метода GetSortedArray в коде программы.](#описание-метода-getsortedarray-в-коде-программы)
    + [Текстовое описание алгоритма работы метода GetSortedArray.](#текстовое-описание-алгоритма-работы-метода-getsortedarray)
___
+ [Описание алгоритма блока вывода.](#описание-алгоритма-блока-вывода)
    + [Текстовое описание работы алгоритма метода по выводу результирующего массива, PrintReport.](#текстовое-описание-работы-алгоритма-метода-по-выводу-результирующего-массива-printreport)
    + [Описание метода PrintReport в коде программы.](#описание-метода-printreport-в-коде-программы)
____________
+ Благодарность
____

*Итак, приступим!*

## **Общее описание алгоритма программы.**
______
### **Общая блок-схема алгоритма решения задачи.**
![Общая блок-схема](diagrams/GeneralBlockDiagram.jpg)

### **Текстовое описание общей работы алгоритма программы.**

*Первоначально наша программа очищает консоль пользователя, при помощью команды Console.Clear(); , дабы не засорять консоль при многочисленных вызовах программы.*

```C#
Console.Clear();
```

*Далее мы создаем и инициализируем переменную целочисленную arrayLength, обращаясь для этого к методу GetValueFromUser(message, errorMessage) и передавая ему две строки в качестве аргумента, которые будут приглашать пользователя к вводу. В свою очередь метод будет возвращать целочисленное значение длины массива, полученное от пользователя, предварительно проверив пользовательский ввод на ошибку, дабы пользователь не ввёл других символов, кроме числа  и значение было больше 0.*

```C#
int arrayLength = GetValueFromUser("Введите желаемую длину массива, не равную 0: ", "Ошибка ввода!Повторите попытку!");
```

*Далее мы создаем и инициализируем переменную, которая получит и будет хранить наш исходный массив строк. Сделаем мы это при помощи метода GetAndFillArrayByUser(arrayLength). Данный метод получает в качестве аргумента нашу переменную arrayLength, которая на данный момент содержит необходимое значение длины массива, затем при помощи данного значения длины создаёт и инициализирует внутреннию переменную строчного массива, которая будет хранить массив, полученный в результате работы метода, приглашает пользователя к вводу данных и на основе полученных данных формирует и возвращает нам нужный массив, который в дальнейшем будет считаться исходным.*

```C#
string[] array = GetAndFillArrayByUser(arrayLength);
```

*Далее наша программа распечатывает исходный массив в консоль с помощью метода PrintArray(array). Это необходимо для того, чтобы пользователь понимал, что программа сформировала массив на основе его данных.*

```C#
PrintArray(array);
```

*Затем мы создаем и инициализируем переменную result, которая будет хранить наш результирующий массив строк, полученный в результате работы программы. Происходит это путём обращения к методу GetSortedArray(array), который получает в качестве аргумента наш исходный массив, сортирует его элементы согласно условию нашей задачи, формирует новый массив, полученный на осонове результатов сортировки и возвращает его.*

```C#
string[] result = GetSortedArray(array);
```
*В конце работы нашей программы мы выводим полученный результирующий массив пользователю в консоль, если вдруг массив пуст, то мы выводим вместо массива сообщение пользователю о том, что в результате сортировки в исходном массиве нет элементов удовлетворяющих условию задачи. Это достигнуто путём обращения к методу PrintReport(result), который получает в качестве аргумента наш результирующий массив.*

```C#
PrintReport(result);
```
*Работы нашей программы на этом этапе завершается!*

[К списку глав.](#главы)
___________

## **Описание алгоритма блока ввода данных.**
____
### **Блок-Схема аргоритма метода GetValueFromUser.**

![Блок-Схема метода GetValueFromUser](diagrams/GetValueFromUserBlockDiagram.jpg)

### **Описание метода GetValueFromUser в коде программы.**

```C#
int GetValueFromUser(string message, string errorMessage)
{
    while (true)
    {
        Console.Write(message);
        if (int.TryParse(Console.ReadLine(), out int userValue) && userValue > 0)
            return userValue;
        Console.WriteLine(errorMessage);
    }
}
```

### **Текстовое описание алгоритма работы  метода GetValueFromUser.**

*Данный метод работает путём обращения к "бесконечному" циклу while, который изначально содержит в себе значине true, поэтому метод не сможет прекратить свою работу без принудительной команды. Сделано это для того, чтобы при ошибке ввода наша программа снова запрашивала у пользователя ввод данных , а не "крашилась" и прочее.*

*После погружения в тело цикла whilе, наш метод выводит в консоль сообщение о приглашении к вводу данных путём использования команды Console.Write(message), которая выводит наш параметр message, содержащий строку, полученную как аргумент.*

*Далее стоит условие, что если при попытке преобразовании строки в целое число метод int.TryParse вернёт значение типа bool - true и это значение будет > 0, то всё условие вернёт значение true и наш метод вернёт переменную userValue, которая содержит целое число и которая была получена в результате преобразования строки методом int.TryParse, затем метод завершит свою работу. Если же всё условие вернёт false, то наш метод выведет сообщение в консоль о том, что произошла ошибка ввода данных и предложит попробовать снова, а затем наш цикл while начнётся заного и будет работать до тех пор, пока метод не получит корректный ввод от пользователя, согласно условию if. Достигнуто это путём вызова метода WriteLine класса Console, который получает параметр errorMessage, который в свою очередь содержит сообщение об ошибке, полученное через аргумент метода.*

### **Блок-Схема алгоритма метода GetAndFillArrayByUser.**

![Блок-Схема метода GetAndFillArrayByUser](diagrams/GetAndFillArrayByUserBlockDiagram.jpg)

### **Описание метода GetAndFillArrayByUser в коде программы.**

```C#
string[] GetAndFillArrayByUser(int size)
{
    string[] res = new string[size];

    for (int i = 0; i < res.Length; i++)
    {
        Console.Write($"Введите элемент массива под номером {i + 1}: ");

        res[i] = Console.ReadLine()!;
    }
    return res;
}
```

### **Текстовое описание алгоритма работы метода GetAndFillArrayByUser.**

*В данном методе изначально создаётся и инициализируется переменная res, которая имеет тип данных string[], она будет хранит массив, полученный в результате работы нашего метода. Инициализируется данная переменная командой new string[size]
, где size - это параметр, содержащий длину массива, полученную от пользователя, полученную в качестве аргумента.*

*Далее при помощи цикла for мы объявлем целочисленную переменную i, равную 0. i в данном случае будет являтся индексом нашего массива. Далее выставлено условия , что если i < res.Length(эта команда означает длинну массива res), то условие цикла for вернёт результат типа bool равный true и мы спустимся в тело цикла, где при помощи команды Console.Write будет выведено сообщение с использованием интерполяции строк(символ $). Данное сообщение будет приглашать пользователя к вводу элементов массива под номером, который задается значением переменной i + 1 на каждой итерации. Сделано это для того, чтобы при выводе в консоль для рядового пользователя индексация начиналась не с 0 , а с 1. Так людям, которые не знакомы с программированием, привычнее.*

*Затем значение элемента массива res с текущим индексом i (res[i]) будет равнятся тому, что вернёт наш метод ReadLine класса Console. Данный метод считывает строку из консоли.*

*После всего этого мы возвращаемся к условию цикла for, в котором также указан инкримент переменной i (i++). Переменная i будет увеличина на 1 и мы снова будет проверять условия цикла. Наш цикл будет работать до тех пор, пока результат сравнения i < res.Length не вернёт результат типа bool равное false. В таком случае наш метод вернёт значение переменной res, которая будет хранить наш полученный , а далее исходный массив и наш метод закончит свою работу.*

[К списку глав.](#главы)
____

## **Описание алгоритма блока операций с полученными данными.**
___

### **Текстовое описание работы алгоритма метода по выводу исходного массива, PrintArray.**

*Данный метод получает через параметр string[] arr исходный массив ввиде аргумента и выводит его в консоль при помощи сочетании метода WriteLine класса Console и метода Join класса String. Весь вывод сопровождает сообщение о том, что это исходный, сгенерированный массив. Данный метод имеет тип void, так как он ничего не возвращает.*

### **Описание метода PrintArray в коде программы.**

```C#
void PrintArray(string[] arr)
{
    Console.WriteLine($"В результате полученных данных сгенерирован массив: [{String.Join(", ", arr)}]");
}
```

### **Блок-Схема алгоритма метода GetSortedArray.**

![Блок-Схема Алгоритма GetSortedArray](diagrams/GetSortedArrayBlockDiagram.jpg)

### **Описание метода GetSortedArray в коде программы.**

```C#
string[] GetSortedArray(string[] arr)
{
    int i = 0;
    string[] res = new string[i];

    foreach (string el in arr)
    {
        if (el.Length <= 3)
        {
            Array.Resize(ref res, res.Length + 1);
            res[i] = el;
            i++;
        }
    }
    return res;
}
```

### **Текстовое описание алгоритма работы метода GetSortedArray.**

*Данный метод в начале своей работы определяет целочисленную переменную i, которая равняется 0. Это будет индексом нашего результирующего массива. Также определяется переменная типа string[] под названием res, которая инициализируется командой new string[i]. Данная переменная будет хранить наш результирующий массив, полученный в результате работы нашего метода. Длина массива определяется i равным 0 , на данный момент.*

*Затем мы обращаемся к циклу foreach и определяем в нём условия (string el in arr), где string el - это внутренняя переменная, которая создается для обращения и работы с элементами исходного массива, который в свою очередь находится в параметре arr и передан через аргумент. Таким образом цикл foreach(string el in arr) можно понимать так: "Для каждого строчного элемента массива в массиве arr".Если el лежит в массиве arr, то данное условие цикла foreach возвращает результат типа данных bool равный true и мы спускаемся в тело цикла.*

*В теле цикла мы определяем ещё одно условие, в котором сравниваем длину элемента исходного массива со значением 3 (el.Length <= 3). Если результат условия возвращает true, то в таком случае мы спускаемся в тело данного условия и производим следующие операции. Мы производим изменение нашего результирующего массива res путём обращения к методу Resize класса Array, для того , чтобы в нашем массиве появился ячейка для хранения строки , подошевшего под наше условие.При каждом выполнении условия if и спуске к данной команде мы будет увеличивать размер результирующего массива путём аргумента метода Resize, а именно res.Length + 1. Далее мы определяем, что наш элемент массива res с индексом i (res[i]) равняется el, то есть элементу исходного массива, который подошел под условие. По завершению тела данного условия мы производим инкримент переменной i, для увеличения индекса и возвращаемся к условия foreach.Если же условие нашего if вернуло результат типа bool равный false, то мы также возвращаемся к условию foreach.*

*Как только тело цикла foreach вернёт нам результат false (то есть мы пройдём по всем элементам массива), то наш метод вернёт значение переменной res и наш метод завершит свою работу.*

[К списку глав.](#главы)
____

## **Описание алгоритма блока вывода.**
_____

### **Текстовое описание работы алгоритма метода по выводу результирующего массива, PrintReport.**

*Данный метод получает в качестве аргумента наш результирующий массив, полученный в процессе работы программы и проверяет через условие if длину нашего массива.*

*Если длина массива > 0 (res.Length > 0), то нашего условие if возвращает результат типа bool равный true и наш метод распечатывает массив в консоль путём обращения к сочетанию методов WriteLine класса Console и методу Join класса String.При этом также выводится сообщение о том , что это результат работы программы и это результирующий массив.*

*В ином же варианте , если наше условие if вернёт результат false, то наш метод выведёт сообщение в консоль о том, что в исходном массиве не оказалось элементов удовлетворяющих нашему условию, а именно длина элемента должна быть меньше или равна 3 символам. Сделано это для того, чтобы пользователь понимал результат и для того, чтобы пользователь не видел просто пустой массив.*

*Данный метод имеет класс void, так как ничего не возвращает.*

### Описание метода PrintReport в коде программы.

```C#
void PrintReport(string[] res)
{
    if (res.Length > 0)
        Console.WriteLine($"В результате сортировки получен массив: [{String.Join(", ", res)}]");
    else
        Console.WriteLine("В данном массиве нет строчных элементов, длина которых меньше или равна 3 символам.");
}
```

[К списку глав.](#главы)
______
## Благодарность

*Спасибо всем, кого заинтересовало прочесть весь этот труд, а особенно преподавателей GeekBrains! Надеюсь, что вам понравилось и было интересно. Хорошего дня!*

![Картина благодарности](https://api.psychologos.ru/storage/image/b0b48c8b44ea272f59896a1be14fe7dd.jpg)

[К списку глав.](#главы)